# 系统设计思路

本轮相当于对项目代码进行重写, 因此需要进行整体预设计

# 基本功能模块

- Electron
  - 提供运行平台
  - 支持系统操作
- GUI
  - 通过 vue3 实现
  - 提供操作界面
  - 和 Electron 交互, 触发指令
  - 提供一个方便的接口调试界面, 用于测试知乎 api
- Node
  - 运行任务
    - 抓取任务
    - 生成任务
    - 工具性任务
      - 创建数据库

# Node

## 基本设计原则

1.  导出时使用具名导出, 而非 default 导出, 方便跟踪导入结果
    1.  这个思路不妥
    2.  合理的做法是只导出一个值, 所有值都挂载到这一个类目下边.
    3.  一个文件中导出多个类本身就预示着设计失败.
    4.  所以, 所有导出统一使用 default 导出, 而非具名导出.
2.  所有单词统一使用单数, 避免名词复数拼写不一致问题
3.  文件名使用下划线分割, 以适配大小写不敏感的文件系统
4.  使用具名对象形式传递参数, 而非数组形式. 适配部分参数为非必填的情况
5.  涉及时间的单位, 统一使用 ms, 变量名后加\_ms 后缀, 方便增加可读性
6.  对于所有 id, 统一视为字符串进行处理
7.  使用 MTotalAnswer 统一管理回答. 如果问题下没有回答, 则可以略过问题展示(这样可以将回答相关数据源都收拢到 TotalAnswer 表中, 不需要来回更新数据)
8.  类是用于保存状态的数据类型, 如果数据本身没有状态, 更适合用接口
    1.  由于知乎助手中的数据类型不涉及状态信息, 因此使用纯接口类型更合适(这里使用 type 实现), 而非使用 class
9.  时间戳统一为秒级
10. 数据库查询, 如果没有数据, 列表值默认返回空数组, 对象值默认返回空对象
11. 不支持将问题/回答/想法单独生成电子书, 这种类型数据单独输出意义不大, 只能合并后进行输出

## 任务类型

- 容器类型
  - 问题
  - 专栏
  - 收藏夹
  - 话题
  - 用户
    - 点赞
    - 提问
    - 回答
    - 文章
    - 想法
- 元素类型
  - 回答
  - 想法
  - 文章

## 项目结构

- api
  - 封装知乎接口调用
- command
  - fetch 抓取
  - generate 生成
  - init_env 初始化数据库
  - test 测试命令, 用于 debug
  - dispatch_task 根据任务配置, 执行指定任务
- config
  - base_info
    - 基础信息
      - 当前版本号
      - 升级检测接口
  - database
    - 数据库版本号
  - path
    - 文件路径, 所有路径均通过`config/path`获取
      - 项目根路径
      - 数据库文件位置
      - package.json 文件位置
      - 缓存文件
        - 图片缓存
        - html 缓存
      - 输出目录
        - epub 输出
        - html 输出
  - request
    - 最大并发请求数
    - 默认 ua 值
- constant
  - 常量
  - 常量数不大, 因此可以集中编写, 不需要额外拆分
- library
  - epub 生成
  - http 网络请求
  - zhihu_encrypt 知乎加密算法, 参考[链接](https://github.com/niudai/VSCode-Zhihu/blob/master/src/util/g_encrypt.js)
  - knex 数据库
  - logger 统一日志打印
    - 需确认是否需要该 logger, 因为使用后会找不到文件位置
- model
  - 封装各种数据类型的数据库操作
- public
  - 资源地址
  - template
    - react
      - react 渲染模板, 用于生成 html
    - epub
      - epub 相关模板
- type
  - 数据类型定义

# 并发任务控制

目前是做了两层并发任务控制:

对于多个电子书生成任务, 会将其加入到任务进程中, 并发执行

对于每一个电子书生成任务, 只会按顺序执行. 内部使用 loopCounter 记录当前任务数, 由内部控制并发数

但这样是不妥的. 因为期望的是: 每本电子书独立生成, 电子书内部任务可以并发执行, 但有任务队列控制.

对并发任务的需求是:

1.  有全局的总体控制
2.  我能知道当前对象加进去的所有任务何时全部执行完成(而不是等到全部执行完成后才能知道)
    1.  换言之, 允许添加任务时, 为任务添加 label
    2.  允许查询当前指定 label 下的任务是否全部完成
    3.  因此, 任务队列需要维护一张表, 记录对应 label 下, 当前有多少任务, 是否已完成
    4.  支持返回一个 promise, 当 label 下所有任务均已完成时, reslove
